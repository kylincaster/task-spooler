//
// Created by justanhduc on 24/08/2022.
//
#include "version.h"

#include <stdio.h>
#include <time.h>

int main() {
    FILE *f = fopen("ts.1", "w");
    time_t T = time(NULL);
    struct tm tm = *localtime(&T);
    if (f == NULL)
    {
        printf("Error opening file!\n");
        return 1;
    }
    char manPage[100000];
#ifndef CPU
    sprintf(manPage, ".\\\" Copyright Llu√≠s Batlle i Rossell\n"
                     ".\\\"\n"
                     ".\\\" This file may be copied under the conditions described\n"
                     ".\\\" in the LDP GENERAL PUBLIC LICENSE, Version 1, September 1998\n"
                     ".\\\" that should have been distributed together with this file.\n"
                     ".\\\" \n"
                     ".\\\" Note: I took the gnu 'ls' man page as an example.\n"
                     ".TH TS 1 %04d-%02d \"Task Spooler %s\"\n"
                     ".SH NAME\n"
                     "ts \\- Task Spooler. A simple unix batch system\n"
                     ".SH SYNOPSIS\n"
                     ".BI \"ts [\" actions \"] [\" options \"] [\" command... ]\n"
                     ".sp\n"
                     "Actions:\n"
                     ".BI \"[\\-KClhVTRqMg]\n"
                     ".BI \"[\\-M [\"format ]]\n"
                     ".BI \"[\\-t [\"id ]]\n"
                     ".BI \"[\\-c [\"id ]]\n"
                     ".BI \"[\\-p [\"id ]]\n"
                     ".BI \"[\\-o [\"id ]]\n"
                     ".BI \"[\\-s [\"id ]]\n"
                     ".BI \"[\\-r [\"id ]]\n"
                     ".BI \"[\\-w [\"id ]]\n"
                     ".BI \"[\\-k [\"id ]]\n"
                     ".BI \"[\\-u [\"id ]]\n"
                     ".BI \"[\\-i [\"id ]]\n"
                     ".BI \"[\\-U <\"id - id >]\n"
                     ".BI \"[\\-S [\"num ]]\n"
                     ".BI \"[\\-a/--get_label [\"id ]]\n"
                     ".BI \"[\\-F/--full_cmd [\"id ]]\n"
                     ".BI \"[\\--getenv [\"var ]]\n"
                     ".BI \"[\\--setenv [\"var=val ]]\n"
                     ".BI \"[\\--unsetenv [\"var ]]\n"
                     ".BI \"[\\--set_gpu_free_perc [\"num ]]\n"
                     ".BI \"[\\--set_gpu_free_perc ]\n"
                     ".BI \"[\\--get_logdir]\n"
                     ".BI \"[\\--set_logdir [\"path ]]\n"
                     "\n"
                     ".sp\n"
                     "Options:\n"
                     ".BI \"[\\-BnEfzmd]\"\n"
                     ".BI \"[\\-L [\"label ]]\n"
                     ".BI \"[\\-D [\"id1,id2,... ]]\n"
                     ".BI \"[\\-W [\"id1,id2,... ]]\n"
                     ".BI \"[\\-G/--gpus [\"num ]]\n"
                     ".BI \"[\\-g/--gpus_indices [\"id1,id2,... ]]\n"
                     ".BI \"[\\-O [\"name ]]\n"
                     ".BI \"[\\-N [\"num ]]\n"
                     "\n"
                     ".SH DESCRIPTION\n"
                     ".B ts\n"
                     "will run by default a per user unix task queue. The user can add commands to\n"
                     "the queue, watch that queue at any moment, and look at the task results\n"
                     "(actually, standard output and exit error).\n"
                     ".SH SIMPLE USE\n"
                     "Calling\n"
                     ".B ts\n"
                     "with a command will add that command to the queue, and calling it without\n"
                     "commands or parameters will show the task list.\n"
                     ".SH COMMAND OPTIONS\n"
                     "When adding a job to ts, we can specify how it will be run and how the\n"
                     "results will be collected:\n"
                     ".TP\n"
                     ".B \"\\-n\"\n"
                     "Do not store the standard output/error in a file at\n"
                     ".B $TMPDIR\n"
                     "- let it use the\n"
                     "file descriptors decided by the calling process. If it is not used, the\n"
                     ".B jobid\n"
                     "for the new task will be output to stdout.\n"
                     ".TP\n"
                     ".B \"\\-z\"\n"
                     "Pass the output through gzip (only if\n"
                     ".B \\-n\n"
                     "). Note that the output files will not\n"
                     "have a .gz extension.\n"
                     ".TP\n"
                     ".B \"\\-f\"\n"
                     "Don not put the task into background. Wait the queue and the command run without\n"
                     "getting detached of the terminal. The exit code will be that of the command, and\n"
                     "if used together with \\-n, no result will be stored in the queue.\n"
                     ".TP\n"
                     ".B \"\\-m\"\n"
                     "Mail the results of the command (output and exit code) to\n"
                     ".B $TS_MAILTO\n"
                     ", or to the\n"
                     ".B $USER\n"
                     "using\n"
                     ".B /usr/sbin/sendmail.\n"
                     "Look at\n"
                     ".B ENVIRONMENT.\n"
                     ".TP\n"
                     ".B \"\\-L [label]\"\n"
                     "Add a label to the task, which will appear next to its command when listing\n"
                     "the queue. It makes more comfortable distinguishing similar commands with\n"
                     "different goals.\n"
                     ".TP\n"
                     ".B \"\\-d\"\n"
                     "Run the command only after the last command finished.\n"
                     "It does not depend on how its dependency ends.\n"
                     ".TP\n"
                     ".B \"\\-D [id,...]\"\n"
                     "Run the command only after the specified job IDs finished.\n"
                     "It does not depend on how its dependencies end.\n"
                     ".TP\n"
                     ".B \"\\-W [id,...]\"\n"
                     "Run the command only if the job of given id finished well (errorlevel = 0). This new\n"
                     "task enqueued depends on the result of the previous command. If the task is not run,\n"
                     "it is considered as failed for further dependencies.\n"
                     "If the server doesn't have the job id in its list, it will be considered\n"
                     "as if the job failed.\n"
                     ".TP\n"
                     ".B \"\\-B\"\n"
                     "In the case the queue is full (due to \\fBTS_MAXCONN\\fR or system limits),\n"
                     "by default ts will block the enqueuing command. Using \\fB\\-B\\fR,\n"
                     "if the queue is full it will exit returning the value 2 instead of blocking.\n"
                     ".TP\n"
                     ".B \"\\-E\"\n"
                     "Keep two different output files for the command stdout and stderr. stdout goes to\n"
                     "the file announced by ts (look at \\fB\\-o\\fR), and stderr goes to the stdout file\n"
                     "with an additional \".e\". For example, /tmp/ts-out.SKsDw8 and /tmp/ts-out.SKsDw8.e.\n"
                     "Only the stdout file gets created with \\fBmkstemp\\fR, ensuring it does not overwrite\n"
                     "any other; the \".e\" will be overwritten if it existed.\n"
                     ".TP\n"
                     ".B \"\\-O [name]\"\n"
                     "Set the log name to the specified name. Do not include any path in the specified name.\n"
                     ".TP\n"
                     ".B \"\\-N [num]\"\n"
                     "Run the command only if there are \\fbnum\\fB slots free in the queue. Without it,\n"
                     "the job will run if there is one slot free. For example, if you use the\n"
                     "queue to feed cpu cores, and you know that a job will take two cores, with \\fB\\-N\\fB\n"
                     "you can let ts know that.\n"
                     ".TP\n"
                     ".B \"\\-G/--gpus [num]\"\n"
                     "Run the job with \\fbnum\\fB GPUs.\n"
                     ".TP\n"
                     ".B \"\\-g/--gpu_indices [id,...]\"\n"
                     "Run the job with the specified GPU IDs. GPU IDs should be separated by commas.\n"
                     ".SH ACTIONS\n"
                     "Instead of giving a new command, we can use the parameters for other purposes:\n"
                     ".TP\n"
                     ".B \"\\--getenv [var]\"\n"
                     "Get the specified environment variable value from the\n"
                     ".B ts\n"
                     "server.\n"
                     ".TP\n"
                     ".B \"\\--setenv [var]\"\n"
                     "Set the specified environment variable to the\n"
                     ".B ts\n"
                     "server.\n"
                     ".TP\n"
                     ".B \"\\--unsetenv [var]\"\n"
                     "Remove the specified environment variable from the\n"
                     ".B ts\n"
                     "server.\n"
                     ".TP\n"
                     ".B \"\\--set_gpu_free_perc [num]\"\n"
                     "Set the value of GPU memory threshold above which GPUs are considered available (90 by default).\n"
                     ".TP\n"
                     ".B \"\\--get_gpu_free_perc\"\n"
                     "Get the value of GPU memory threshold above which GPUs are considered available.\n"
                     ".TP\n"
                     ".B \"\\-K\"\n"
                     "Kill the\n"
                     ".B ts\n"
                     "server for the calling client. This will remove the unix socket and\n"
                     "all the\n"
                     ".B ts\n"
                     "processes related to the queue. This will not kill the command being\n"
                     "run at that time.\n"
                     "\n"
                     "It is not reliable to think that\n"
                     ".B ts -K\n"
                     "will finish when the server is really killed. By now it is a race condition.\n"
                     ".TP\n"
                     ".B \"\\-T\"\n"
                     "Send SIGTERM to all running job groups.\n"
                     ".TP\n"
                     ".B \"\\-C\"\n"
                     "Clear the results of finished jobs from the queue.\n"
                     ".TP\n"
                     ".B \"\\-l\"\n"
                     "Show the list of jobs - to be run, running and finished - for the current queue.\n"
                     "This is the default behaviour if\n"
                     ".B ts\n"
                     "is called without options.\n"
                     ".TP\n"
                     ".B \"\\-M [format]\"\n"
                     "Print output in a machine-readable format. Choices: {default, json, tab}.\n"
                     ".TP\n"
                     ".B \"\\-g\"\n"
                     "list all jobs running on GPUs and the corresponding GPU IDs.\n"
                     ".TP\n"
                     ".B \"\\-q/--last_queue_id\"\n"
                     "Show the job ID of the last added.\n"
                     ".TP\n"
                     ".B \"\\-R/--count_running\"\n"
                     "Return the number of running jobs\n"
                     ".TP\n"
                     ".B \"\\-a/--get_label [id]\"\n"
                     "Show the job label. Of the last added, if not specified.\n"
                     ".TP\n"
                     ".B \"\\-F/--full_cmd [id]\"\n"
                     "Show the full command. Of the last added, if not specified.\n"
                     ".TP\n"
                     ".B \"\\--get_logdir\"\n"
                     "Show the path containing log files.\n"
                     ".TP\n"
                     ".B \"\\--set_logdir [path]\"\n"
                     "Set the path containing log files to the specified path.\n"
                     ".TP\n"
                     ".B \"\\-t [id]\"\n"
                     "Show the last ten lines of the output file of the named job, or the last\n"
                     "running/run if not specified. If the job is still running, it will keep on\n"
                     "showing the additional output until the job finishes. On exit, it returns the\n"
                     "errorlevel of the job, as in \\fB\\-c\\fR.\n"
                     ".TP\n"
                     ".B \"\\-c [id]\"\n"
                     "Run the system's cat to the output file of the named job, or the last\n"
                     "running/run if not specified. It will block until all the output can be\n"
                     "sent to standard output, and will exit with the job errorlevel as in\n"
                     "\\fB\\-c\\fR.\n"
                     ".TP\n"
                     ".B \"\\-p [id]\"\n"
                     "Show the pid of the named job, or the last running/run if not specified.\n"
                     ".TP\n"
                     ".B \"\\-o [id]\"\n"
                     "Show the output file name of the named job, or the last running/run \n"
                     "if not specified.\n"
                     ".TP\n"
                     ".B \"\\-s [id]\"\n"
                     "Show the job state of the named job, or the last in the queue.\n"
                     ".TP\n"
                     ".B \"\\-r [id]\"\n"
                     "Remove the named job, or the last in the queue.\n"
                     ".TP\n"
                     ".B \"\\-w [id]\"\n"
                     "Wait for the named job, or for the last in the queue.\n"
                     ".TP\n"
                     ".B \"\\-k [id]\"\n"
                     "Kill the process group of the named job (SIGTERM),\n"
                     "or the last running/run job if not specified.\n"
                     "Equivalent to\n"
                     ".B kill -- -`ts -p`\n"
                     ".TP\n"
                     ".B \"\\-u [id]\"\n"
                     "Make the named job (or the last in the queue) urgent - this means that it goes\n"
                     "forward in the queue so it can run as soon as possible.\n"
                     ".TP\n"
                     ".B \"\\-i [id]\"\n"
                     "Show information about the named job (or the last run). It will show the command line,\n"
                     "some times related to the task, and also any information resulting from\n"
                     "\\fBTS_ENV\\fR (Look at \\fBENVIRONMENT\\fR).\n"
                     ".TP\n"
                     ".B \"\\-U <id-id>\"\n"
                     "Interchange the queue positions of the named jobs (separated by a hyphen and no\n"
                     "spaces).\n"
                     ".TP\n"
                     ".B \"\\-h\"\n"
                     "Show help on standard output.\n"
                     ".TP\n"
                     ".B \"\\-V\"\n"
                     "Show the program version.\n"
                     ".SH MULTI-SLOT\n"
                     ".B ts\n"
                     "by default offers a queue where each job runs only after the previous finished.\n"
                     "Nevertheless, you can change the maximum number of jobs running at once with\n"
                     "the\n"
                     ".B \"\\-S [num]\"\n"
                     "parameter. We call that number the\n"
                     "\\fIamount of slots\\fR. You can also set the initial number of jobs with\n"
                     "the environment variable\n"
                     ".B \"TS_SLOTS\".\n"
                     "When increasing this setting, queued waiting jobs will be run\n"
                     "at once until reaching the maximum set. When decreasing this setting, no other\n"
                     "job will be run until it can meet the amount of running jobs set.\n"
                     ".BR\n"
                     "When using an amount of slots greater than 1, the action of some commands\n"
                     "may change a bit. For example, \\fB\\-t\\fR without \\fIjobid\\fR will tail the first\n"
                     "job running, and \\fB\\-d\\fR will try to set the dependency with the last job added.\n"
                     ".TP\n"
                     ".B \"\\-S [num]\"\n"
                     "Set the maximum amount of running jobs at once. If you don't specify\n"
                     ".B num\n"
                     "it will return the maximum amount of running jobs set.\n"
                     "\n"
                     "\n"
                     ".SH ENVIRONMENT\n"
                     ".TP\n"
                     ".B \"TS_VISIBLE_DEVICES\"\n"
                     "Similar to CUDA_VISIBLE_DEVICES, if a comma-separated string of GPU IDs is provided,\n"
                     "ts will run jobs on only these devices.\n"
                     ".TP\n"
                     ".B \"TS_MAXFINISHED\"\n"
                     "Limit the number of job results (finished tasks) you want in the queue. Use this\n"
                     "option if you are tired of\n"
                     ".B \\-C.\n"
                     ".TP\n"
                     ".B \"TS_MAXCONN\"\n"
                     "The maximum number of ts server connections to clients. This will make the ts clients\n"
                     "block until connections are freed. This helps, for example, on systems with a limited\n"
                     "number of processes, because each job waiting in the queue remains as a process. This\n"
                     "variable has to be set at server start, and cannot be modified later.\n"
                     ".TP\n"
                     ".B \"TS_ONFINISH\"\n"
                     "If the variable exists pointing to an executable, it will be run by the client\n"
                     "after the queued job. It uses execlp, so\n"
                     ".B PATH\n"
                     "is used if there are no slashes in the variable content. The executable is run\n"
                     "with four parameters:\n"
                     ".B jobid\n"
                     ".B errorlevel\n"
                     ".B output_filename\n"
                     "and\n"
                     ".B command.\n"
                     ".TP\n"
                     ".B \"TMPDIR\"\n"
                     "As the program output and the unix socket are thought to be stored in a\n"
                     "temporary directory, \n"
                     ".B TMPDIR\n"
                     "will be used if defined, or\n"
                     ".B /tmp\n"
                     "otherwise.\n"
                     ".TP\n"
                     ".B \"TS_SOCKET\"\n"
                     "Each queue has a related unix socket. You can specify the socket path with this\n"
                     "environment variable. This way, you can have a queue for your heavy disk\n"
                     "operations, another for heavy use of ram., and have a simple script/alias\n"
                     "wrapper over ts for those special queues. If it is not specified, it will be\n"
                     ".B $TMPDIR/socket-ts.[uid].\n"
                     ".TP\n"
                     ".B \"TS_SLOTS\"\n"
                     "Set the number of slots at the start of the server, similar to\n"
                     ".B \\-S,\n"
                     "but the contents of the variable are read only when running\n"
                     "the first instance of\n"
                     ".B ts.\n"
                     ".TP\n"
                     ".B \"TS_MAILTO\"\n"
                     "Send the letters with job results to the address specified in this variable.\n"
                     "Otherwise, they are sent to\n"
                     ".B $USER\n"
                     "or if not defined,\n"
                     ".B nobody.\n"
                     "The system\n"
                     ".B /usr/sbin/sendmail\n"
                     "is used. The\n"
                     "job outputs are not sent as an attachment, so understand the consequences if you\n"
                     "use the\n"
                     ".B \\-gm\n"
                     "flags together.\n"
                     ".TP\n"
                     ".B \"USER\"\n"
                     "As seen above, it is used for the mail destination if\n"
                     ".B TS_MAILTO\n"
                     "is not specified.\n"
                     ".TP\n"
                     ".B \"TS_SAVELIST\"\n"
                     "If it is defined when starting the queue server (probably the first\n"
                     ".B ts\n"
                     "command run), on SIGTERM the queue status will be saved to the file pointed\n"
                     "by this environment variable - for example, at system shutdown.\n"
                     ".TP\n"
                     ".B \"TS_ENV\"\n"
                     "This has a command to be run at enqueue time through\n"
                     "\\fB/bin/sh\\fR. The output of the command will be readable through the option\n"
                     "\\fB\\-i\\fR. You can use a command which shows relevant environment for the command run.\n"
                     "For example, you may use \\fBTS_ENV='pwd;set;mount'\\fR.\n"
                     ".SH FILES\n"
                     ".TP\n"
                     ".B /tmp/ts.error\n"
                     "if\n"
                     ".B ts\n"
                     "finds any internal problem, you should find an error report there.\n"
                     "Please send this to the author as part of the bug report.\n"
                     "\n"
                     ".SH BUGS\n"
                     ".B ts\n"
                     "expects a simple command line. It does not start a shell parser.\n"
                     "If you want to run complex shell commands, you may want to run them through\n"
                     ".B sh -c 'commands...'\n"
                     "Also, remember that stdin/stdout/stderr will be detached, so\n"
                     "do not use your shell's redirection operators when you put a job into background.\n"
                     "You can use them inside the\n"
                     ".B sh -c\n"
                     "in order to set redirections to the command run.\n"
                     "\n"
                     "If an internal problem is found in runtime, a file\n"
                     ".B /tmp/ts.error\n"
                     "is created, which you can submit to the developer in order to fix the bug.\n"
                     "\n"
                     ".SH SEE ALSO\n"
                     ".BR at (1)\n"
                     ".SH AUTHOR\n"
                     "Duc Nguyen and Lluis Batlle i Rossell\n"
                     ".SH NOTES\n"
                     "This page describes\n"
                     ".B ts\n"
                     "as in version %s. Other versions may differ. The file\n"
                     ".B TRICKS\n"
                     "found in the distribution package can show some ideas on special uses of\n"
                     ".B ts.", tm.tm_year + 1900, tm.tm_mon + 1, TS_MAKE_STR(TS_VERSION), TS_MAKE_STR(TS_VERSION));
#else
    sprintf(manPage, ".\\\" Copyright Llu√≠s Batlle i Rossell\n"
                     ".\\\"\n"
                     ".\\\" This file may be copied under the conditions described\n"
                     ".\\\" in the LDP GENERAL PUBLIC LICENSE, Version 1, September 1998\n"
                     ".\\\" that should have been distributed together with this file.\n"
                     ".\\\" \n"
                     ".\\\" Note: I took the gnu 'ls' man page as an example.\n"
                     ".TH TS 1 %04d-%02d \"Task Spooler %s\"\n"
                     ".SH NAME\n"
                     "ts \\- Task Spooler. A simple unix batch system\n"
                     ".SH SYNOPSIS\n"
                     ".BI \"ts [\" actions \"] [\" options \"] [\" command... ]\n"
                     ".sp\n"
                     "Actions:\n"
                     ".BI \"[\\-KClhVTRqM]\n"
                     ".BI \"[\\-M [\"format ]]\n"
                     ".BI \"[\\-t [\"id ]]\n"
                     ".BI \"[\\-c [\"id ]]\n"
                     ".BI \"[\\-p [\"id ]]\n"
                     ".BI \"[\\-o [\"id ]]\n"
                     ".BI \"[\\-s [\"id ]]\n"
                     ".BI \"[\\-r [\"id ]]\n"
                     ".BI \"[\\-w [\"id ]]\n"
                     ".BI \"[\\-k [\"id ]]\n"
                     ".BI \"[\\-u [\"id ]]\n"
                     ".BI \"[\\-i [\"id ]]\n"
                     ".BI \"[\\-U <\"id - id >]\n"
                     ".BI \"[\\-S [\"num ]]\n"
                     ".BI \"[\\-a/--get_label [\"id ]]\n"
                     ".BI \"[\\-F/--full_cmd [\"id ]]\n"
                     ".BI \"[\\--getenv [\"var ]]\n"
                     ".BI \"[\\--setenv [\"var=val ]]\n"
                     ".BI \"[\\--unsetenv [\"var ]]\n"
                     ".BI \"[\\--get_logdir]\n"
                     ".BI \"[\\--set_logdir [\"path ]]\n"
                     "\n"
                     ".sp\n"
                     "Options:\n"
                     ".BI \"[\\-BnEfzmd]\"\n"
                     ".BI \"[\\-L [\"label ]]\n"
                     ".BI \"[\\-D [\"id1,id2,... ]]\n"
                     ".BI \"[\\-W [\"id1,id2,... ]]\n"
                     ".BI \"[\\-O [\"name ]]\n"
                     ".BI \"[\\-N [\"num ]]\n"
                     "\n"
                     ".SH DESCRIPTION\n"
                     ".B ts\n"
                     "will run by default a per user unix task queue. The user can add commands to\n"
                     "the queue, watch that queue at any moment, and look at the task results\n"
                     "(actually, standard output and exit error).\n"
                     ".SH SIMPLE USE\n"
                     "Calling\n"
                     ".B ts\n"
                     "with a command will add that command to the queue, and calling it without\n"
                     "commands or parameters will show the task list.\n"
                     ".SH COMMAND OPTIONS\n"
                     "When adding a job to ts, we can specify how it will be run and how the\n"
                     "results will be collected:\n"
                     ".TP\n"
                     ".B \"\\-n\"\n"
                     "Do not store the standard output/error in a file at\n"
                     ".B $TMPDIR\n"
                     "- let it use the\n"
                     "file descriptors decided by the calling process. If it is not used, the\n"
                     ".B jobid\n"
                     "for the new task will be output to stdout.\n"
                     ".TP\n"
                     ".B \"\\-z\"\n"
                     "Pass the output through gzip (only if\n"
                     ".B \\-n\n"
                     "). Note that the output files will not\n"
                     "have a .gz extension.\n"
                     ".TP\n"
                     ".B \"\\-f\"\n"
                     "Don not put the task into background. Wait the queue and the command run without\n"
                     "getting detached of the terminal. The exit code will be that of the command, and\n"
                     "if used together with \\-n, no result will be stored in the queue.\n"
                     ".TP\n"
                     ".B \"\\-m\"\n"
                     "Mail the results of the command (output and exit code) to\n"
                     ".B $TS_MAILTO\n"
                     ", or to the\n"
                     ".B $USER\n"
                     "using\n"
                     ".B /usr/sbin/sendmail.\n"
                     "Look at\n"
                     ".B ENVIRONMENT.\n"
                     ".TP\n"
                     ".B \"\\-L [label]\"\n"
                     "Add a label to the task, which will appear next to its command when listing\n"
                     "the queue. It makes more comfortable distinguishing similar commands with\n"
                     "different goals.\n"
                     ".TP\n"
                     ".B \"\\-d\"\n"
                     "Run the command only after the last command finished.\n"
                     "It does not depend on how its dependency ends.\n"
                     ".TP\n"
                     ".B \"\\-D [id,...]\"\n"
                     "Run the command only after the specified job IDs finished.\n"
                     "It does not depend on how its dependencies end.\n"
                     ".TP\n"
                     ".B \"\\-W [id,...]\"\n"
                     "Run the command only if the job of given id finished well (errorlevel = 0). This new\n"
                     "task enqueued depends on the result of the previous command. If the task is not run,\n"
                     "it is considered as failed for further dependencies.\n"
                     "If the server doesn't have the job id in its list, it will be considered\n"
                     "as if the job failed.\n"
                     ".TP\n"
                     ".B \"\\-B\"\n"
                     "In the case the queue is full (due to \\fBTS_MAXCONN\\fR or system limits),\n"
                     "by default ts will block the enqueuing command. Using \\fB\\-B\\fR,\n"
                     "if the queue is full it will exit returning the value 2 instead of blocking.\n"
                     ".TP\n"
                     ".B \"\\-E\"\n"
                     "Keep two different output files for the command stdout and stderr. stdout goes to\n"
                     "the file announced by ts (look at \\fB\\-o\\fR), and stderr goes to the stdout file\n"
                     "with an additional \".e\". For example, /tmp/ts-out.SKsDw8 and /tmp/ts-out.SKsDw8.e.\n"
                     "Only the stdout file gets created with \\fBmkstemp\\fR, ensuring it does not overwrite\n"
                     "any other; the \".e\" will be overwritten if it existed.\n"
                     ".TP\n"
                     ".B \"\\-O [name]\"\n"
                     "Set the log name to the specified name. Do not include any path in the specified name.\n"
                     ".TP\n"
                     ".B \"\\-N [num]\"\n"
                     "Run the command only if there are \\fbnum\\fB slots free in the queue. Without it,\n"
                     "the job will run if there is one slot free. For example, if you use the\n"
                     "queue to feed cpu cores, and you know that a job will take two cores, with \\fB\\-N\\fB\n"
                     "you can let ts know that.\n"
                     ".SH ACTIONS\n"
                     "Instead of giving a new command, we can use the parameters for other purposes:\n"
                     ".TP\n"
                     ".B \"\\--getenv [var]\"\n"
                     "Get the specified environment variable value from the\n"
                     ".B ts\n"
                     "server.\n"
                     ".TP\n"
                     ".B \"\\--setenv [var]\"\n"
                     "Set the specified environment variable to the\n"
                     ".B ts\n"
                     "server.\n"
                     ".TP\n"
                     ".B \"\\--unsetenv [var]\"\n"
                     "Remove the specified environment variable from the\n"
                     ".B ts\n"
                     "server.\n"
                     ".TP\n"
                     ".B \"\\-K\"\n"
                     "Kill the\n"
                     ".B ts\n"
                     "server for the calling client. This will remove the unix socket and\n"
                     "all the\n"
                     ".B ts\n"
                     "processes related to the queue. This will not kill the command being\n"
                     "run at that time.\n"
                     "\n"
                     "It is not reliable to think that\n"
                     ".B ts -K\n"
                     "will finish when the server is really killed. By now it is a race condition.\n"
                     ".TP\n"
                     ".B \"\\-T\"\n"
                     "Send SIGTERM to all running job groups.\n"
                     ".TP\n"
                     ".B \"\\-C\"\n"
                     "Clear the results of finished jobs from the queue.\n"
                     ".TP\n"
                     ".B \"\\-l\"\n"
                     "Show the list of jobs - to be run, running and finished - for the current queue.\n"
                     "This is the default behaviour if\n"
                     ".B ts\n"
                     "is called without options.\n"
                     ".TP\n"
                     ".B \"\\-M [format]\"\n"
                     "Print output in a machine-readable format. Choices: {default, json, tab}.\n"
                     ".TP\n"
                     ".B \"\\-q/--last_queue_id\"\n"
                     "Show the job ID of the last added.\n"
                     ".TP\n"
                     ".B \"\\-R/--count_running\"\n"
                     "Return the number of running jobs\n"
                     ".TP\n"
                     ".B \"\\-a/--get_label [id]\"\n"
                     "Show the job label. Of the last added, if not specified.\n"
                     ".TP\n"
                     ".B \"\\-F/--full_cmd [id]\"\n"
                     "Show the full command. Of the last added, if not specified.\n"
                     ".TP\n"
                     ".B \"\\--get_logdir\"\n"
                     "Show the path containing log files.\n"
                     ".TP\n"
                     ".B \"\\--set_logdir [path]\"\n"
                     "Set the path containing log files to the specified path.\n"
                     ".TP\n"
                     ".B \"\\-t [id]\"\n"
                     "Show the last ten lines of the output file of the named job, or the last\n"
                     "running/run if not specified. If the job is still running, it will keep on\n"
                     "showing the additional output until the job finishes. On exit, it returns the\n"
                     "errorlevel of the job, as in \\fB\\-c\\fR.\n"
                     ".TP\n"
                     ".B \"\\-c [id]\"\n"
                     "Run the system's cat to the output file of the named job, or the last\n"
                     "running/run if not specified. It will block until all the output can be\n"
                     "sent to standard output, and will exit with the job errorlevel as in\n"
                     "\\fB\\-c\\fR.\n"
                     ".TP\n"
                     ".B \"\\-p [id]\"\n"
                     "Show the pid of the named job, or the last running/run if not specified.\n"
                     ".TP\n"
                     ".B \"\\-o [id]\"\n"
                     "Show the output file name of the named job, or the last running/run \n"
                     "if not specified.\n"
                     ".TP\n"
                     ".B \"\\-s [id]\"\n"
                     "Show the job state of the named job, or the last in the queue.\n"
                     ".TP\n"
                     ".B \"\\-r [id]\"\n"
                     "Remove the named job, or the last in the queue.\n"
                     ".TP\n"
                     ".B \"\\-w [id]\"\n"
                     "Wait for the named job, or for the last in the queue.\n"
                     ".TP\n"
                     ".B \"\\-k [id]\"\n"
                     "Kill the process group of the named job (SIGTERM),\n"
                     "or the last running/run job if not specified.\n"
                     "Equivalent to\n"
                     ".B kill -- -`ts -p`\n"
                     ".TP\n"
                     ".B \"\\-u [id]\"\n"
                     "Make the named job (or the last in the queue) urgent - this means that it goes\n"
                     "forward in the queue so it can run as soon as possible.\n"
                     ".TP\n"
                     ".B \"\\-i [id]\"\n"
                     "Show information about the named job (or the last run). It will show the command line,\n"
                     "some times related to the task, and also any information resulting from\n"
                     "\\fBTS_ENV\\fR (Look at \\fBENVIRONMENT\\fR).\n"
                     ".TP\n"
                     ".B \"\\-U <id-id>\"\n"
                     "Interchange the queue positions of the named jobs (separated by a hyphen and no\n"
                     "spaces).\n"
                     ".TP\n"
                     ".B \"\\-h\"\n"
                     "Show help on standard output.\n"
                     ".TP\n"
                     ".B \"\\-V\"\n"
                     "Show the program version.\n"
                     ".SH MULTI-SLOT\n"
                     ".B ts\n"
                     "by default offers a queue where each job runs only after the previous finished.\n"
                     "Nevertheless, you can change the maximum number of jobs running at once with\n"
                     "the\n"
                     ".B \"\\-S [num]\"\n"
                     "parameter. We call that number the\n"
                     "\\fIamount of slots\\fR. You can also set the initial number of jobs with\n"
                     "the environment variable\n"
                     ".B \"TS_SLOTS\".\n"
                     "When increasing this setting, queued waiting jobs will be run\n"
                     "at once until reaching the maximum set. When decreasing this setting, no other\n"
                     "job will be run until it can meet the amount of running jobs set.\n"
                     ".BR\n"
                     "When using an amount of slots greater than 1, the action of some commands\n"
                     "may change a bit. For example, \\fB\\-t\\fR without \\fIjobid\\fR will tail the first\n"
                     "job running, and \\fB\\-d\\fR will try to set the dependency with the last job added.\n"
                     ".TP\n"
                     ".B \"\\-S [num]\"\n"
                     "Set the maximum amount of running jobs at once. If you don't specify\n"
                     ".B num\n"
                     "it will return the maximum amount of running jobs set.\n"
                     "\n"
                     "\n"
                     ".SH ENVIRONMENT\n"
                     ".TP\n"
                     ".B \"TS_MAXFINISHED\"\n"
                     "Limit the number of job results (finished tasks) you want in the queue. Use this\n"
                     "option if you are tired of\n"
                     ".B \\-C.\n"
                     ".TP\n"
                     ".B \"TS_MAXCONN\"\n"
                     "The maximum number of ts server connections to clients. This will make the ts clients\n"
                     "block until connections are freed. This helps, for example, on systems with a limited\n"
                     "number of processes, because each job waiting in the queue remains as a process. This\n"
                     "variable has to be set at server start, and cannot be modified later.\n"
                     ".TP\n"
                     ".B \"TS_ONFINISH\"\n"
                     "If the variable exists pointing to an executable, it will be run by the client\n"
                     "after the queued job. It uses execlp, so\n"
                     ".B PATH\n"
                     "is used if there are no slashes in the variable content. The executable is run\n"
                     "with four parameters:\n"
                     ".B jobid\n"
                     ".B errorlevel\n"
                     ".B output_filename\n"
                     "and\n"
                     ".B command.\n"
                     ".TP\n"
                     ".B \"TMPDIR\"\n"
                     "As the program output and the unix socket are thought to be stored in a\n"
                     "temporary directory, \n"
                     ".B TMPDIR\n"
                     "will be used if defined, or\n"
                     ".B /tmp\n"
                     "otherwise.\n"
                     ".TP\n"
                     ".B \"TS_SOCKET\"\n"
                     "Each queue has a related unix socket. You can specify the socket path with this\n"
                     "environment variable. This way, you can have a queue for your heavy disk\n"
                     "operations, another for heavy use of ram., and have a simple script/alias\n"
                     "wrapper over ts for those special queues. If it is not specified, it will be\n"
                     ".B $TMPDIR/socket-ts.[uid].\n"
                     ".TP\n"
                     ".B \"TS_SLOTS\"\n"
                     "Set the number of slots at the start of the server, similar to\n"
                     ".B \\-S,\n"
                     "but the contents of the variable are read only when running\n"
                     "the first instance of\n"
                     ".B ts.\n"
                     ".TP\n"
                     ".B \"TS_MAILTO\"\n"
                     "Send the letters with job results to the address specified in this variable.\n"
                     "Otherwise, they are sent to\n"
                     ".B $USER\n"
                     "or if not defined,\n"
                     ".B nobody.\n"
                     "The system\n"
                     ".B /usr/sbin/sendmail\n"
                     "is used. The\n"
                     "job outputs are not sent as an attachment, so understand the consequences if you\n"
                     "use the\n"
                     ".B \\-gm\n"
                     "flags together.\n"
                     ".TP\n"
                     ".B \"USER\"\n"
                     "As seen above, it is used for the mail destination if\n"
                     ".B TS_MAILTO\n"
                     "is not specified.\n"
                     ".TP\n"
                     ".B \"TS_SAVELIST\"\n"
                     "If it is defined when starting the queue server (probably the first\n"
                     ".B ts\n"
                     "command run), on SIGTERM the queue status will be saved to the file pointed\n"
                     "by this environment variable - for example, at system shutdown.\n"
                     ".TP\n"
                     ".B \"TS_ENV\"\n"
                     "This has a command to be run at enqueue time through\n"
                     "\\fB/bin/sh\\fR. The output of the command will be readable through the option\n"
                     "\\fB\\-i\\fR. You can use a command which shows relevant environment for the command run.\n"
                     "For example, you may use \\fBTS_ENV='pwd;set;mount'\\fR.\n"
                     ".SH FILES\n"
                     ".TP\n"
                     ".B /tmp/ts.error\n"
                     "if\n"
                     ".B ts\n"
                     "finds any internal problem, you should find an error report there.\n"
                     "Please send this to the author as part of the bug report.\n"
                     "\n"
                     ".SH BUGS\n"
                     ".B ts\n"
                     "expects a simple command line. It does not start a shell parser.\n"
                     "If you want to run complex shell commands, you may want to run them through\n"
                     ".B sh -c 'commands...'\n"
                     "Also, remember that stdin/stdout/stderr will be detached, so\n"
                     "do not use your shell's redirection operators when you put a job into background.\n"
                     "You can use them inside the\n"
                     ".B sh -c\n"
                     "in order to set redirections to the command run.\n"
                     "\n"
                     "If an internal problem is found in runtime, a file\n"
                     ".B /tmp/ts.error\n"
                     "is created, which you can submit to the developer in order to fix the bug.\n"
                     "\n"
                     ".SH SEE ALSO\n"
                     ".BR at (1)\n"
                     ".SH AUTHOR\n"
                     "Duc Nguyen and Lluis Batlle i Rossell\n"
                     ".SH NOTES\n"
                     "This page describes\n"
                     ".B ts\n"
                     "as in version %s. Other versions may differ. The file\n"
                     ".B TRICKS\n"
                     "found in the distribution package can show some ideas on special uses of\n"
                     ".B ts.", tm.tm_year + 1900, tm.tm_mon + 1, TS_MAKE_STR(TS_VERSION), TS_MAKE_STR(TS_VERSION));
#endif
    fprintf(f, "%s", manPage);
    return 0;
}
